# 1
'''
    Реализовать класс «Дата», функция-конструктор которого должна принимать дату в виде строки формата «день-месяц-год». 
    В рамках класса реализовать два метода. 
    Первый, с декоратором @classmethod, должен извлекать число, месяц, год и преобразовывать их тип к типу «Число». 
    Второй, с декоратором @staticmethod, должен проводить валидацию числа, месяца и года (например, месяц — от 1 до 12). 
    Проверить работу полученной структуры на реальных данных.
'''
class Data:
    def __init__(self, data):
        self.data = data
        
    @classmethod
    def month(cls, data):
        return [int(el) for el in data.split('-')]

    @staticmethod
    def valid_data(data):
        data = [int(el) for el in data.split('-')]

        if data[0] > 31:
            data[0] -= 31
        if data[1] > 12:
            data[1] -= 12

        return data


print(Data.month('28-5-2020'), Data.valid_data('42-15-2020'), sep='\n')

# 2
'''
    Создайте собственный класс-исключение, обрабатывающий ситуацию деления на нуль. 
    Проверьте его работу на данных, вводимых пользователем. 
    При вводе пользователем нуля в качестве делителя программа должна корректно обработать эту ситуацию и не завершиться с ошибкой.
'''
try:
    print(int(input('Делимое ')) / int(input('Делитель ')))
except ZeroDivisionError:
    print(0)

# 3
'''
    Создайте собственный класс-исключение, который должен проверять содержимое списка на наличие только чисел. 
    Проверить работу исключения на реальном примере. 
    Необходимо запрашивать у пользователя данные и заполнять список. 
    Класс-исключение должен контролировать типы данных элементов списка.

    Примечание: длина списка не фиксирована. 
    Элементы запрашиваются бесконечно, пока пользователь сам не остановит работу скрипта, введя, например, команду “stop”. 
    При этом скрипт завершается, сформированный список выводится на экран.

    Подсказка: для данного задания примем, что пользователь может вводить только числа и строки. 
    При вводе пользователем очередного элемента необходимо реализовать проверку типа элемента и вносить его в список, только если введено число. 
    Класс-исключение должен не позволить пользователю ввести текст (не число) и отобразить соответствующее сообщение. 
    При этом работа скрипта не должна завершаться.
'''
el_list = []
user_el = 0

print('exit = exit()')
while user_el != 'exit':
    user_el = input('el ')

    try:
        if user_el.isdigit() == False:
            raise
    except:
        pass
    else:
        el_list.append(user_el)

print(el_list)


# 4
'''
    Начните работу над проектом «Склад оргтехники». 
    Создайте класс, описывающий склад. 
    А также класс «Оргтехника», который будет базовым для классов-наследников. 
    Эти классы — конкретные типы оргтехники (принтер, сканер, ксерокс). 
    В базовом классе определить параметры, общие для приведенных типов. 
    В классах-наследниках реализовать параметры, уникальные для каждого типа оргтехники. 
'''
# 5
'''
    Продолжить работу над первым заданием. 
    Разработать методы, отвечающие за приём оргтехники на склад и передачу в определенное подразделение компании. 
    Для хранения данных о наименовании и количестве единиц оргтехники, а также других данных, можно использовать любую подходящую структуру, например словарь.
'''
# 6
'''
    Продолжить работу над вторым заданием. 
    Реализуйте механизм валидации вводимых пользователем данных. 
    Например, для указания количества принтеров, отправленных на склад, нельзя использовать строковый тип данных. 

    Подсказка: постарайтесь по возможности реализовать в проекте «Склад оргтехники» максимум возможностей, изученных на уроках по ООП.    
'''


class Warehouse:
    def __init__(self):
        self.map_warehouse = [
                {'Printer' : []},
                {'Scanner' : []},
                {'Xerax' : []}
        ]



class Technics:
    def __init__(self, name, name_laibal, price):
        self.name = str(name)
        self.name_laibal = str(name_laibal)
        self.price = int(price)

        if self.name == 'Printer':
            self.idx_warehouse = 0
        elif  self.name == 'Scanner':
            self.idx_warehouse = 1
        elif self.name == 'Xerax':
            self.idx_warehouse = 2
        else:
            pass # next technics

    def push_in_warehouse(self):
        warehouse.map_warehouse[self.idx_warehouse][self.name].append(self)

    def calculeit_technics(self):
        return len(warehouse.map_warehouse[self.idx_warehouse][self.name])

    def draw(self):
        print(self.calculeit_technics())
        print(warehouse.map_warehouse[self.idx_warehouse][self.name])


class Printer(Technics):
    pass


class Scanner(Technics):
    pass


class Xerax(Technics):
    pass


warehouse = Warehouse()

technic_1 = Printer('Printer', 'samsung', 1000)
technic_2 = Scanner('Scanner', 'samsung', '1000')
technic_3 = Xerax('Xerax', 'samsung', 1000)

technic_1.push_in_warehouse()

technic_1.draw()
technic_2.draw()
technic_3.draw()


